[values]
ScratchDisk = "/dev/sda"
TestSuiteImage = "drbd9-tests"
RDMA = "" # set to "true" to enable
Storage = "lvm" # Also possible: raw and zfs
OutDir = ""
DrbdVersion = "" # validate that this DRBD version is installed
DrbdVersionOther = ""

[[steps]]
[steps.shell]
script = '''
set -e

case "$DRBD_TEST_STORAGE" in
lvm)
    if ! vgs scratch; then
	    vgcreate scratch "$SCRATCH_DISK"
	    lvcreate --thin --size 1G scratch/drbdthinpool
    fi
    ;;
raw)
    ;;
zfs)
    zpool create scratch $SCRATCH_DISK
    ;;
*)
    echo "Unknown storage backend" 1>&2
    exit 1
    ;;
esac

# Find the default route which must have a /24 address range.
default_gateway=$(ip route show to 0.0.0.0/0 | awk {'print $3'})
default_route=$(ip route show to match $default_gateway | grep /24)

# Find the device for the default route.
dev=$(printf "%s" "$default_route" | awk '{print $3}')

if [ "$DRBD_TEST_RDMA" = "true" ] ; then
	# Ensure that an RDMA link is available.
	if ! rdma link show | grep ^ ; then
		modprobe rdma_rxe
		echo $dev > /sys/module/rdma_rxe/parameters/add
	fi
fi

# cloud-init configuration with multiple interfaces is tricky, and sometimes they fail.
# Just ignore those services.
systemctl reset-failed "network*.service" || true

while true; do
	running=$(systemctl is-system-running || true)
	[ "$running" = initializing -o "$running" = starting ] && { sleep 1; continue; }
	[ "$running" = running ] && break
	echo "System in unexpected state '$running'; failed units:" 1>&2
	systemctl list-units --failed 1>&2
	exit 1
done
'''
[steps.shell.env]
SCRATCH_DISK = "{{.ScratchDisk}}"
DRBD_TEST_STORAGE = "{{.Storage}}"
DRBD_TEST_RDMA = "{{.RDMA}}"

[[steps]]
[steps.docker]
image = "{{.TestSuiteImage}}"
[steps.docker.env]
SCRATCH_DISK = "{{.ScratchDisk}}"
DRBD_TEST_STORAGE = "{{.Storage}}"
DRBD_TEST_RDMA = "{{.RDMA}}"
DRBD_VERSION = "{{.DrbdVersion}}"
DRBD_VERSION_OTHER = "{{.DrbdVersionOther}}"
[steps.docker.copy]
source = "/log"
dest = "{{.OutDir}}"
