#! /usr/bin/env python3

# This test checks drbd's ability to perform a resync under heavy
# application IO stress.
#
# Phases of this test:
# 1) A new data generation is generated by disconnecting the nodes
#    and writing a large amount of data (80MiB) on one of them.
#
# 2) The node with the up-to-date data generation repeatedly writes
#    to the disk to generate lots of IO requests.
#
# 3) The nodes are reconnected, which should trigger a resync.
#
# 4) Slowly but surely, the resync should finish in finite time.

from python import drbdtest
from python.drbdtest import log
import time


resource = drbdtest.setup(nodes=2)
writing_n = resource.nodes[0]
other_nodes = resource.nodes.difference([writing_n])
writing_conn = drbdtest.Connection(writing_n, other_nodes[0])
to_writing = drbdtest.Connection(other_nodes[0], writing_n)
resource.add_disk('128M')
resource.up_wait()

log('* Make up-to-date data available.')
resource.skip_initial_sync()

writing_n.primary()

resource.nodes.drbdadm(['peer-device-options', '--c-min-rate', '100M', 'all'])

# disconnect writing node
writing_conn.disconnect()
to_writing.event(r'connection .* connection:TearDown')
to_writing.event(r'connection .* connection:Connecting')

# write to node
writing_n.volumes.write(size='80M', offset='20M', direct=1)

# run fio in background
fio_cmd = ['setsid', 'bash', '-c',
        'fio --max-jobs=1 --name=test --filename={} --ioengine=libaio --rw=write --direct=1 --iodepth=32 '.format(writing_n.volumes[0].device()) +
        # Some fio versions (including fio-3.16 on Ubuntu Focal) ignore "size"
        # when "time_based" is given. Use an offset after the dirty region so
        # that this job does not overwrite it. Otherwise the application IO
        # from this job will enable DRBD to finish the sync regardless of
        # whether the busy resync problem occurred or not.
        '--offset=100M ' +
        '--size=8M --time_based --runtime=600 < /dev/null &> /dev/null & echo $!']
fio_pid = writing_n.run(fio_cmd, return_stdout=True)

# reconnect
writing_conn.connect()

# the resync is expected to take a while because heavy IO
# is going on in the background. we just want to check if
# it gets there eventually, so wait for the intermediate
# progress events and check if any significant progress
# is made.
initial_oos = 0
while initial_oos == 0:
    progress_event = r'peer-device .* out-of-sync:([0-9]+)|call .* helper:(after-resync-target)'
    done = other_nodes.event(progress_event)
    initial_oos = int(done[0][0])

while True:
    done = other_nodes.event(progress_event)
    if len(done[0]) > 1 and done[0][1] == 'after-resync-target':
        # resync finished
        break
    else:
        oos = int(done[0][0])
        if initial_oos - oos > 1000:
            # test successful after 1000 synced blocks (arbitrary limit)
            break

writing_n.run(['kill', str(fio_pid)])
# wait for fio to terminate
writing_n.run(['tail', '--pid={}'.format(fio_pid), '-f', '/dev/null'])
writing_n.secondary()

log('* Shut down and clean up.')

resource.down()
resource.teardown()
