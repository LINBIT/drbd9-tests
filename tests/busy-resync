#! /usr/bin/env python

# This test checks drbd's ability to perform a resync under heavy
# application IO stress.
#
# Phases of this test:
# 1) A new data generation is generated by disconnecting the nodes
#    and writing a large amount of data (80MiB) on one of them.
#
# 2) The node with the up-to-date data generation repeatedly writes
#    to the disk to generate lots of IO requests.
#
# 3) The nodes are reconnected, which should trigger a resync.
#
# 4) Slowly but surely, the resync should finish in finite time.

from python import drbdtest
from python.drbdtest import verbose
import time
from threading import Thread

def write_on_node(node):
    for v in node.volumes:
        # write 80 MiB at offset 20 MiB
        node.run(['dd', 'if=/dev/urandom', 'of=%s' % (v.device()) , 'bs=4096',
                  'seek=5120', 'count=20480', 'conv=fsync'])

def fio_thread(args):
    writing_n = args
    # run fio in background
    fio_cmd = ['setsid', 'bash', '-c', 'fio --runtime=600 --bs=4k --ioengine=sync --verify=meta --verify_interval=4k --filename=' + str(writing_n.volumes[0].device()) + ' --name=write_loop --rw=write --direct=1 --iodepth=32 --offset=8m --size=8m --do_verify=0 --time_based < /dev/null &> /dev/null &']
    writing_n.run(fio_cmd)


resource = drbdtest.setup(min_nodes=2, max_nodes=2)
writing_n = resource.nodes[0]
other_nodes = resource.nodes.difference([writing_n])
writing_conn = drbdtest.Connection(writing_n, other_nodes[0])
to_writing = drbdtest.Connection(other_nodes[0], writing_n)
resource.add_disk('128M')
resource.up_wait()

verbose('* Make up-to-date data available.')
resource.skip_initial_sync()

writing_n.primary()

resource.nodes.run(['drbdadm', 'peer-device-options', '--c-min-rate', '100M', 'all', '-v'])

# disconnect writing node
writing_conn.disconnect()
to_writing.event(r'connection .* connection:TearDown')
to_writing.event(r'connection .* connection:Connecting')

# dirty bitmap
write_on_node(writing_n)

# reconnect
writing_conn.connect()

# start fio
thread = Thread(target = fio_thread, args=(writing_n, ))
thread.start()

# the resync is expected to take a while because heavy IO
# is going on in the background. we just want to check if
# it gets there eventually, so wait for the intermediate
# progress events and check if any significant progress
# is made.
initial_oos = 0
while initial_oos == 0:
    progress_event = r'peer-device .* out-of-sync:([0-9]+)|call .* helper:(after-resync-target)'
    done = other_nodes.event(progress_event)
    initial_oos = int(done[0][0])

while True:
    done = other_nodes.event(progress_event)
    if len(done[0]) > 1 and done[0][1] == 'after-resync-target':
        # resync finished
        break
    else:
        oos = int(done[0][0])
        if initial_oos - oos > 1000:
            # test successful after 1000 synced blocks (arbitrary limit)
            break

writing_n.run(['killall', '-9', 'fio'])

thread.join()

verbose('* Shut down and clean up.')

resource.down()
resource.rmmod()
