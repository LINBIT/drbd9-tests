#! /bin/bash

# FIXME: Verify the disk contents as well!

TOP=${0%/*}/..
. $TOP/lib/setup.sh

setup --min-nodes=3 --disk=10M "$@"

first_node=${NODES[0]}
last_node=${NODES[@]:(-1)}

# List of connections that form a chain, for example,
#   ( A:B B:C C:D D:E )
chain=()
for ((i = 0; i < ${#NODES[@]} - 1; i++)); do
    chain[i]="${NODES[i]}:${NODES[i+1]}"
done
chain=( "${chain[@]}" $(reverse_connections "${chain[@]}") )

verbose "* Set up and wait for the cluster to stabilize."
_up
_wait_connected
_force_primary
_initial_resync
on "$first_node" drbdadm secondary all
event "$first_node" -y 'resource .* role:Secondary'
connection_event $(all_connections_to $first_node) -y 'connection .* role:Secondary'

# Remove forbidden patterns related to connection failures: this test case
# exercises disconnects and connection failures.
remove_forbidden_patterns \
	'connection:Timeout' \
	'connection:BrokenPipe'

verbose "* Turn cluster into a chain of nodes."
# FIXME: All disks must stay UpToDate ...
#add_forbidden_patterns 'disk:(?!UpToDate).*'
_disconnect $(all_connections_except "${chain[@]}")
#remove_forbidden_patterns 'disk:(?!UpToDate).*'

write_on_primary() {
    local v1=($(volumes_on $first_node))
    local v2=(${v1[@]/$first_node:/$RESOURCE\/})
    local volume device
    for volume in ${v2[@]}; do
	device=$(on $first_node drbdadm sh-dev $volume)
	on "$first_node" dd if=/dev/zero of=$device bs=4096 count=1
    done
}

wait_backward_propagating_resyncs() {
    local idx from to volumes from_to_volumes
    for (( idx=${#NODES[@]}-1 ; idx>=3 ; idx-- )) ; do
	from=${NODES[$idx]}
	to=${NODES[$idx-1]}
	volumes=($(volumes_on $from))
	from_to_volumes=(${volumes[@]/$from:/$from:$to:})
	to_from_volumes=(${volumes[@]/$from:/$to:$from:})
	peer_device_event "${from_to_volumes[@]}" -y 'peer-device .* replication:SyncSource'
	peer_device_event "${from_to_volumes[@]}" -y 'peer-device .* replication:Established'
	peer_device_event "${to_from_volumes[@]}" -y 'peer-device .* replication:SyncTarget'
	peer_device_event "${to_from_volumes[@]}" -y 'peer-device .* replication:Established'
    done
}

outdate_test() {
    local write="$1"

    verbose "* Make a node primary and see if volumes on weak nodes become Outdated."
    on "$first_node" drbdadm primary all
    weak_nodes=( $(all_nodes_except $first_node ${NODES[1]}) )
    volume_event $(volumes_on "${weak_nodes[@]}") -y 'device .* disk:Outdated'
    [ "$write" ] && write_on_primary

    verbose "* See if node becomes UpToDate when connecting to the primary."
    _bidir_connect "$first_node:$last_node"
    connection_event "$first_node:$last_node" "$last_node:$first_node" \
	-y 'connection .* connection:Connected'
    volume_event $(volumes_on $last_node) -y 'device .* disk:UpToDate'
    peer_device_event "$first_node:$last_node:1" -y 'peer-device .* peer-disk:UpToDate'

    verbose "* See if node becomes Outdated when connection to primary is lost."
    remove_forbidden_patterns \
	'connection:NetworkFailure'
    block_connection "$first_node:$last_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:Outdated'

    connection_event "$first_node:$last_node" -y 'connection .* connection:Unconnected'
    [ "$write" ] && write_on_primary
    [ "$write" ] && wait_backward_propagating_resyncs

    unblock_connection "$first_node:$last_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:UpToDate'
    peer_device_event "$first_node:$last_node:1" -y 'peer-device .* peer-disk:UpToDate'

    add_forbidden_patterns \
	'connection:NetworkFailure'

    verbose "* See if node becomes Outdated when disconnecting from the primary."
    _disconnect_nowait "$first_node:$last_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:Outdated'
    [ "$write" ] && write_on_primary
    [ "$write" ] && wait_backward_propagating_resyncs

    _connect "$first_node:$last_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:UpToDate'
    peer_device_event "$first_node:$last_node:1"  -y 'peer-device .* peer-disk:UpToDate'

    _disconnect_nowait "$last_node:$first_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:Outdated'
    [ "$write" ] && write_on_primary
    [ "$write" ] && wait_backward_propagating_resyncs

    _connect "$last_node:$first_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:UpToDate'
    peer_device_event "$first_node:$last_node:1" -y 'peer-device .* peer-disk:UpToDate'

    _disconnect_nowait "$first_node:$last_node" "$last_node:$first_node"
    volume_event $(volumes_on $last_node) -y 'device .* disk:Outdated'
    [ "$write" ] && write_on_primary
    [ "$write" ] && wait_backward_propagating_resyncs

    verbose "* Turn primary into secondary and see if previously weak nodes become UpToDate."
    on "$first_node" drbdadm secondary all
    volume_event $(volumes_on "${weak_nodes[@]}") --timeout=6000 -y 'device .* disk:UpToDate'
}

outdate_test
outdate_test "write_something_between_actions"

_down
_rmmod
