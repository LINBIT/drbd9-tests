#! /usr/bin/env python3
### vmshed: { "vms_all": [3], "vms_ci": null, "drbd_version_min": "9.0" }
#
# This test is similar to the resync-source-becomes-target test. It
# unveiled two bugs in DRBD (up to 9.0.24) which were not uncovered by
# resync-source-becomes-target.
#
# The main differences are that it resyncs a few hundred MBs and it sets
# up DRBD's data structures so that select_best_resync_source() finds
# the candidate before finding the other peer_device

import time
from python import drbdtest
from python.drbdtest import MetadataFlag, connections, log, peer_devices


resource = drbdtest.setup(nodes=3)
resource.add_disk('600M')

[node_a, node_b, node_c] = list(resource.nodes)

log('* Preparing')
flags = MetadataFlag.CONSISTENT | MetadataFlag.WAS_UP_TO_DATE
node_a.set_gi(node_b.volumes[0], 'AAA', 'BBB', 'CCC', flags_set=flags)
node_a.set_gi(node_c.volumes[0], 'AAA', 'BBB', 'CCC', flags_set=flags)
node_b.set_gi(node_c.volumes[0], 'BBB', 'CCC', flags_set=flags)
node_b.set_gi(node_a.volumes[0], 'BBB', 'CCC', flags_set=flags)
node_c.set_gi(node_a.volumes[0], 'CCC', flags_set=flags)

node_a.up()
node_a.volumes[0].write(size='400M', bs='1M', direct=1)
node_b.up_unconnected()
node_b.volumes[0].write(size='300M', bs='1M', direct=1)

log('* Testing')
node_c.up()
pd_c_a = peer_devices(node_c, node_a)

node_b.connect(node_c)
pd_c_b = peer_devices(node_c, node_b)

pd_c_b.event(r'peer-device .* replication:SyncTarget')

node_b.connect(node_a)
pd_b_a = peer_devices(node_b, node_a)

pd_b_a.event(r'peer-device .* replication:SyncTarget')
pd_c_a.event(r'peer-device .* replication:PausedSyncT')
pd_b_a.event(r'peer-device .* replication:Established')
pd_c_b.event(r'peer-device .* replication:Established')
pd_c_a.event(r'peer-device .* replication:SyncTarget')
pd_c_a.event(r'peer-device .* replication:Established')

resource.down()
resource.teardown()
